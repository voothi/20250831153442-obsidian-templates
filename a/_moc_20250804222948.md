<%*
/*
================================================================================
 Скрипт для Templater: Update Hierarchy from MOC
 Версия: 2.1 (Horizontal Hierarchy Support)
 Автор: Gemini AI & User Collaboration
--------------------------------------------------------------------------------
 Назначение:
 Скрипт читает иерархическую структуру из MOC-файла и автоматически
 синхронизирует 'up' property в дочерних заметках.
 Базируется на архитектуре v2.0.

 !!! НОВОЕ в v2.1 !!!
 1. (ПОДДЕРЖКА ГОРИЗОНТАЛЬНОЙ ИЕРАРХИИ) В дополнение к вертикальной
    иерархии (отступы), скрипт теперь обрабатывает ссылки, идущие
    подряд в одной строке, как вложенную иерархию.
    Строка "[[A]] [[B]] [[C]]" будет обработана как A -> B -> C.
 2. Отступ строки определяет родителя для самого первого элемента в строке.
================================================================================
*/

async function updateHierarchyFromMOC(tp) {
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile) {
      new Notice("❌ Ошибка: Нет активного файла для обработки.", 5000);
      return;
  }

  // 1. Получаем исходный текст (только тело заметки или выделение)
  let mocContent = await tp.file.selection();
  if (!mocContent) {
    new Notice("ℹ️ Выделение не найдено. Обрабатывается тело текущей заметки.", 2000);
    const rawContent = await app.vault.read(activeFile);
    const fileCache = app.metadataCache.getFileCache(activeFile);
    if (fileCache && fileCache.frontmatterPosition) {
        mocContent = rawContent.slice(fileCache.frontmatterPosition.end.offset);
    } else {
        mocContent = rawContent;
    }
  }

  const mocFileName = activeFile.basename;

  // 2. Агрегируем всех родителей для каждого дочернего узла
  const parentMap = new Map();
  const lines = mocContent.split('\n').filter(line => line.trim() !== '');
  const parentStack = [];

  // <<< ИЗМЕНЕНИЕ НАЧИНАЕТСЯ ЗДЕСЬ: Новый, улучшенный парсер >>>
  for (const line of lines) {
    const indentMatch = line.match(/^(\s*)/);
    const currentIndent = indentMatch[1].length;

    // Находим ВСЕ вики-ссылки в текущей строке
    const linkMatches = [...line.matchAll(/\[\[(.*?)(?:\|.*?)?\]\]/g)];
    if (linkMatches.length === 0) continue;

    // Определяем родителя для всей строки на основе вертикального отступа
    while (parentStack.length > 0 && parentStack[parentStack.length - 1].indent >= currentIndent) {
      parentStack.pop();
    }
    
    let currentParentLink;
    if (parentStack.length > 0) {
      currentParentLink = `[[${parentStack[parentStack.length - 1].name}]]`;
    } else {
      currentParentLink = `[[${mocFileName}]]`;
    }
    
    // Обрабатываем цепочку ссылок внутри строки
    let lastChildNameInLine = '';
    for (const match of linkMatches) {
        const childName = match[1];

        // Добавляем родителя для текущего узла
        if (!parentMap.has(childName)) {
            parentMap.set(childName, []);
        }
        parentMap.get(childName).push(currentParentLink);

        // Текущий узел становится родителем для следующего в цепочке
        currentParentLink = `[[${childName}]]`;
        lastChildNameInLine = childName;
    }

    // В стек для отступов добавляем ПОСЛЕДНИЙ элемент из цепочки
    if (lastChildNameInLine) {
        parentStack.push({ indent: currentIndent, name: lastChildNameInLine });
    }
  }
  // <<< ИЗМЕНЕНИЕ ЗАКАНЧИВАЕТСЯ ЗДЕСЬ >>>

  // 3. Обновляем frontmatter в файлах (этот блок остался от v2.0)
  if (parentMap.size === 0) {
    new Notice("ℹ️ Не найдено ссылок для обработки в теле заметки/выделении.", 3000);
    return;
  }

  let updatedCount = 0;
  let notFoundCount = 0;
  const notFoundFiles = [];

  new Notice(`⏳ Начинаю обновление... Найдено уникальных узлов: ${parentMap.size}`, 3000);

  // Итерируемся по собранной карте связей
  for (const [childName, newParents] of parentMap.entries()) {
    const childFile = tp.file.find_tfile(childName);

    if (!childFile) {
      console.warn(`Файл не найден для заметки: "${childName}"`);
      notFoundCount++;
      notFoundFiles.push(childName);
      continue;
    }
    
    if (childFile.basename === mocFileName) continue;

    await app.fileManager.processFrontMatter(childFile, (fm) => {
      let currentUp = fm.up || [];
      if (typeof currentUp === 'string') {
        currentUp = [currentUp];
      }
      
      const uniqueNewParents = [...new Set(newParents)].sort();
      const sortedCurrentUp = [...new Set(currentUp)].sort();
      
      const needsUpdate = JSON.stringify(uniqueNewParents) !== JSON.stringify(sortedCurrentUp);

      if (needsUpdate) {
        if (uniqueNewParents.length === 1) {
          fm.up = uniqueNewParents[0];
        } else {
          fm.up = uniqueNewParents;
        }
        updatedCount++;
      }
    });
  }

  // 4. Выводим результат
  let summary = `✅ Обновление завершено.\n`;
  if (updatedCount > 0) {
    summary += `Обновлено 'up' в ${updatedCount} файлах.\n`;
  } else {
    summary += `Все 'up' атрибуты уже были актуальны.\n`;
  }
  
  if (notFoundCount > 0) {
    summary += `\n❌ Не найдено ${notFoundCount} файлов: ${notFoundFiles.join(', ')}`;
    console.error("Не найдены следующие файлы:", notFoundFiles);
  }
  
  const noticeDuration = summary.length > 200 ? 20000 : 10000;
  new Notice(summary, noticeDuration);
}

// Запускаем основную функцию
try {
  await updateHierarchyFromMOC(tp);
} catch (e) {
  new Notice("❌ Произошла критическая ошибка. См. консоль разработчика (Ctrl+Shift+I).", 10000);
  console.error("Templater script error:", e);
}

%>